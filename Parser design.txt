Parser design

The main task of the parser is to build an intermediate representation of the program
based on stream of tokens it gets from the lexer and check if the program is syntactically correct.
If there is an error in syntax of a program, the parser should at least output an error message
with the number of the string where the error occured. Error handling will be described in more detail later.


The source code will be parsed using a recursive-descent method, wich means that the tree is built
from the root towards the leaves and input is scanned from left to right.  
There will be one function implementing each nonterminal. For the grammars to be suitable for our parser,
they must be left-factored and the left recursions must be eliminated. The parser looks one symbol ahead.
Before trying to code things, ambiguities in grammars, too, have to be dealt with.



Lets have a look at the grammar for arithmetic expressions.
First, i'll show you the "wrong" one, explain why its wrong,
and then we will write the "right" grammar.

E -> E + E | E - E | E * E | E / E | id

Here "id" stands for any set of characters and digits, beginning with a character.
A really simple grammar. Whats wrong about it? 
First of all - Left recursion(which can't be parsed by a recursive-descent parser).
Second - Ambiguity. The ambiguous grammars have more than one parse tree for a given string.
It makes the meaning of the expression unambiguous.

Here's an example: 

Let's say we have an expression a + b * c

How is that string derived from the grammar above?
The first option:

E -> E + E -> a + E -> a + E * E -> a + b * E -> a + b * c 

The second option:

E -> E * E -> E + E * E -> a + E * E -> a + b * E -> a + b * c 

So, both of these methods derive the same string a + b * c, but if we would
build a tree while parsing this string, and evaluate the values of these expressions, 
the first option would give us a + (b * c), which is, obiously, the right one, because
multiplication has higher precedence than adding, and the second one, would give us
(a + b) * c, which is wrong. So, in order for our parser to be able to parse the string correctly,
we need to rewrite this grammar.

Here's the "right" way of doing it:

E -> E + T | E - T | T

T -> * F | / F | F 

F -> id | e

Now, you can check that there is only one way of deriving the string a + b * c from this grammar.

Now that we have eliminated the ambiguity in the grammar, is it suitable for our parser? Not really.
The reason is the production  E -> E + T | E - T | T.
Because the leftmost symbol after the -> is equal to that of before ->, it is left recursive.
Luckily, left recursion is easy to eliminate.

E -> T E' | T E'

E' ->  + T E' | -T E' | e

T -> * F | / F | F 

F -> id | e

That's it. 

PS: I don't really understand the problem of ambiguous grammars good enough, so there is a good chance that
some of the things i wrote may be wrong. The example on ambiguity was taken from the dragon book.
I am planning to find out more about that and correct/add something to this.
But anyway, these are the problems of tomorrow me :)




While parsing the string, the parser also has to generate the intermediate representation of the program.
For now, i chose to generate the syntax tree. Three-address code and other intermediate representations can be
generated by traversing the syntax tree.

Here's a syntax tree for expression a + b * c

									   +
									   /\
									  /  \
									 a    *
									 	 / \
									 	/   \
									   b	 c



Example: Construction of Syntax tree.
Error handling.
Left-factoring & Left recursion.




